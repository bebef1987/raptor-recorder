"""Functions to download, install, setup, and use the mitmproxy playback tool"""
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.
from __future__ import absolute_import

import os
import subprocess
import sys
import time

import mozinfo

from mozlog import get_default_logger

here = os.path.dirname(os.path.realpath(__file__))


# path for mitmproxy certificate, generated auto after mitmdump is started
# on local machine it is 'HOME', however it is different on production machines
try:
    DEFAULT_CERT_PATH = os.path.join(os.getenv('HOME'),
                                     '.mitmproxy', 'mitmproxy-ca-cert.cer')
except Exception:
    DEFAULT_CERT_PATH = os.path.join(os.getenv('HOMEDRIVE'), os.getenv('HOMEPATH'),
                                     '.mitmproxy', 'mitmproxy-ca-cert.cer')

# sleep in seconds after issuing a `mitmdump` command
MITMDUMP_SLEEP = 10

# to install mitmproxy certificate into Firefox and turn on/off proxy
POLICIES_CONTENT_ON = '''{
  "policies": {
    "Certificates": {
      "Install": ["%(cert)s"]
    },
    "Proxy": {
      "Mode": "manual",
      "HTTPProxy": "%(host)s:8080",
      "SSLProxy": "%(host)s:8080",
      "Passthrough": "localhost, 127.0.0.1, %(host)s",
      "Locked": true
    }
  }
}'''

POLICIES_CONTENT_OFF = '''{
  "policies": {
    "Proxy": {
      "Mode": "none",
      "Locked": false
    }
  }
}'''


class Mitmproxy():

    def __init__(self, config):

        self.log = get_default_logger(component='recorder-mitmproxy - ')

        self.config = config
        self.mitmproxy_proc = None
        self.mitmdump_path = os.path.join(os.getcwd(),'utils', 'mitmdump')

        self.mitmproxy_recording_path = config['recording']

        self.certutil = "/home/florinstrugariu/mozilla/mozilla-central/obj-x86_64-pc-linux-gnu/dist/bin/certutil"
        self.ld_lib = "/home/florinstrugariu/mozilla/mozilla-central/obj-x86_64-pc-linux-gnu/dist/bin/"

        # mitmproxy must be started before setup, so that the CA cert is available
        self.mitmproxy_proc = self.start_mitmproxy_playback(self.mitmdump_path, self.mitmproxy_recording_path)

        self.install_mitmproxy_cert(self.mitmproxy_proc)

    def start_mitmproxy_playback(self,
                                 mitmdump_path,
                                 mitmproxy_recording_path):
        """Startup mitmproxy and replay the specified flow file"""

        self.log.info("mitmdump path: %s" % mitmdump_path)
        self.log.info("recording path: %s" % mitmproxy_recording_path)

        env = os.environ.copy()

        # mitmproxy needs some DLL's that are a part of Firefox itself, so add to path
        # env["PATH"] = os.path.dirname(browser_path) + ";" + env["PATH"]

        command = [mitmdump_path, '-w', self.mitmproxy_recording_path]

        self.log.info("Starting mitmproxy playback using env path: %s" % env["PATH"])
        self.log.info("Starting mitmproxy playback using command: %s" % ' '.join(command))
        # to turn off mitmproxy log output, use these params for Popen:
        # Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, env=env)
        mitmproxy_proc = subprocess.Popen(command, env=env)
        time.sleep(MITMDUMP_SLEEP)
        data = mitmproxy_proc.poll()
        if data is None:  # None value indicates process hasn't terminated
            self.log.info("Mitmproxy playback successfully started as pid %d" % mitmproxy_proc.pid)
            return mitmproxy_proc
        # cannot continue as we won't be able to playback the pages
        self.log.info('Aborting: mitmproxy playback process failed to start, poll returned: %s' % data)
        sys.exit()

    def stop_mitmproxy_playback(self):
        """Stop the mitproxy server playback"""
        mitmproxy_proc = self.mitmproxy_proc
        self.log.info("Stopping mitmproxy playback, klling process %d" % mitmproxy_proc.pid)
        if mozinfo.os == 'win':
            mitmproxy_proc.kill()
        else:
            mitmproxy_proc.terminate()
        time.sleep(MITMDUMP_SLEEP)
        status = mitmproxy_proc.poll()
        if status is None:  # None value indicates process hasn't terminated
            # I *think* we can still continue, as process will be automatically
            # killed anyway when mozharness is done (?) if not, we won't be able
            # to startup mitmxproy next time if it is already running
            self.log.info("Failed to kill the mitmproxy playback process")
            self.log.error(str(status))
        else:
            self.log.info("Successfully killed the mitmproxy playback process")

    def install_mitmproxy_cert(self, mitmproxy_proc):
        """Install the CA certificate generated by mitmproxy, into geckoview android
        If running locally:
        1. Will use the `certutil` tool from the local Firefox desktop build

        If running in production:
        1. Get the tooltools manifest file for downloading hostutils (contains certutil)
        2. Get the `certutil` tool by downloading hostutils using the tooltool manifest

        Then, both locally and in production:
        1. Create an NSS certificate database in the geckoview browser profile dir, only
           if it doesn't already exist. Use this certutil command:
           `certutil -N -d sql:<path to profile> --empty-password`
        2. Import the mitmproxy certificate into the database, i.e.:
           `certutil -A -d sql:<path to profile> -n "some nickname" -t TC,, -a -i <path to CA.pem>`
        """
        self.CERTUTIL_SLEEP = 10
       
        # when running locally, it is found in the Firefox desktop build (..obj../dist/bin)
         # os.path.join(self.config['obj_path'], 'dist', 'bin')
        os.environ['LD_LIBRARY_PATH'] =  self.ld_lib

        if os.path.isfile(self.certutil):
            self.log.info("certutil is found at: %s" % self.certutil)
        else:
            self.log.info("unable to find certutil at %s" % self.certutil)

        # DEFAULT_CERT_PATH has local path and name of mitmproxy cert i.e.
        # /home/cltbld/.mitmproxy/mitmproxy-ca-cert.cer
        self.local_cert_path = DEFAULT_CERT_PATH

        # check if the nss ca cert db already exists in the device profile
        self.log.info("checking if the nss cert db already exists in the android browser profile")
        param1 = "sql:%s/" % self.config['local_profile_dir']
        command = [self.certutil, '-d', param1, '-L']

        try:
            subprocess.check_output(command, env=os.environ.copy())
            self.log.info("the nss cert db already exists")
            cert_db_exists = True
        except subprocess.CalledProcessError:
            # this means the nss cert db doesn't exist yet
            self.log.info("nss cert db doesn't exist yet")
            cert_db_exists = False

        # try a forced pause between certutil cmds; possibly reduce later
        time.sleep(self.CERTUTIL_SLEEP)

        if not cert_db_exists:
            # create cert db if it doesn't already exist; it may exist already
            # if a previous pageload test ran in the same test suite
            cert_database = "sql:%s/" % self.config['local_profile_dir']
            command = [self.certutil, '-N', '-v', '-d', cert_database, '--empty-password']

            self.log.info("creating nss cert database using command: %s" % ' '.join(command))
            cmd_proc = subprocess.Popen(command, env=os.environ.copy())
            time.sleep(self.CERTUTIL_SLEEP)
            cmd_terminated = cmd_proc.poll()
            if cmd_terminated is None:  # None value indicates process hasn't terminated
                self.log.info("nss cert db creation command failed to complete")

        # import mitmproxy cert into the db
        command = [self.certutil, '-A', '-d', cert_database, '-n',
                   'mitmproxy-cert', '-t', 'TC,,', '-a', '-i', self.local_cert_path]

        self.log.info("importing mitmproxy cert into db using command: %s" % ' '.join(command))
        cmd_proc = subprocess.Popen(command, env=os.environ.copy())
        time.sleep(self.CERTUTIL_SLEEP)
        cmd_terminated = cmd_proc.poll()
        if cmd_terminated is None:  # None value indicates process hasn't terminated
            self.log.info("command to import mitmproxy cert into cert db failed to complete")

        # cannot continue if failed to add CA cert to Firefox, need to check
        if not self.is_mitmproxy_cert_installed():
            self.log.info("Aborting: failed to install mitmproxy CA cert into Firefox")
            self.stop_mitmproxy_playback()
            sys.exit()

    def is_mitmproxy_cert_installed(self):
        """Verify mitmxproy CA cert was added to Firefox on android"""
        self.log.info("verifying that the mitmproxy ca cert is installed on android")

        # list the certifcates that are in the nss cert db (inside the browser profile dir)
        self.log.info("getting the list of certs in the nss cert db in the android browser profile")
        cert_database = "sql:%s/" % self.config['local_profile_dir']
        command = [self.certutil, '-d', cert_database, '-L']

        try:
            cmd_output = subprocess.check_output(command, env=os.environ.copy())

        except subprocess.CalledProcessError:
            # cmd itself failed
            self.log.error("certutil command failed")
            raise

        # check output from the certutil command, see if 'mitmproxy-cert' is listed
        time.sleep(self.CERTUTIL_SLEEP)
        self.log.info(cmd_output)
        if 'mitmproxy-cert' in cmd_output:
            self.log.info("verfied the mitmproxy-cert is installed in the nss cert db on android")
            return True
        return False
